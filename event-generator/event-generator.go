// This program reads the `users.json` file generated by the `user_loader` program and inserts documents into the
// Couchbase bucket based on the action selected in the `whatToDo` constant.
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/couchbase/gocb/v2"
	"github.com/google/uuid"
)

// Update this to your Couchbase server cluster details
const defaultConnectionString = "localhost:12000"
const bucketName = "my-llm"
const scopeName = "users"
const collectionName = "events"

// Update this to your Couchbase server username and password
const defaultUsername = "Administrator"
const defaultPassword = "asdasd"

// action represents the action to be taken based on the users' rate limit
type action int

const (
	// belowRateLimit represents the action wherein, per user, we send half the number of documents as their rate limit
	belowRateLimit action = iota

	// atRateLimit represents the action wherein, per user, we send the number of documents as their rate limit
	atRateLimit

	// aboveRateLimit represents the action wherein, per user, we send twice the number of documents as their rate limit
	aboveRateLimit
)

// whatToDo represents the selected action to be taken based on the users' rate limit
const whatToDo = aboveRateLimit

// UserEventDocument represents the structure of the document to be stored in the Couchbase bucket
type UserEventDocument struct {
	UserID    string `json:"user_id"`
	RespondTo string `json:"respond_to"`
	Payload   string `json:"payload"`
	Header    string `json:"header"`
}

// TierType represents the type of tier a user has
// The TierType determines the rate limit for the user
type TierType string

const (
	Bronze   TierType = "Bronze"
	Silver   TierType = "Silver"
	Gold     TierType = "Gold"
	Platinum TierType = "Platinum"
)

// PackageToLimit returns the rate limit for the given package
func PackageToLimit(pkg TierType) int {
	switch pkg {
	case Bronze:
		return 100
	case Silver:
		return 200
	case Gold:
		return 300
	case Platinum:
		return 400
	default:
		panic("Unknown package")
	}
}

// User represents the structure of a user
type User struct {
	UserID string   `json:"user_id"`
	Tier   TierType `json:"tier"`
}

// Update this to the path where you want to store the generated `users.json` file

// outputFilePath is the path from where we read the `users.json` file generated by the `user_loader` program
var outputFilePath = getEnvOrDefault(
	"USERS_JSON_PATH",
	filepath.Join("/", "Users", "rishitchaudhary", "Dev", "roughpad", "users.json"),
)

func getEnvOrDefault(key, fallback string) string {
	value := os.Getenv(key)
	if value == "" {
		return fallback
	}
	return value
}

func main() {
	// Read the data in the file in the path `outputFilePath` and store it in the variable `users`
	users, err := readFromFile(outputFilePath)
	if err != nil {
		panic(err)
	}

	// Iterate over the `users` slice and print the `UserID` of each user
	for _, user := range users {
		fmt.Println(user.UserID, user.Tier)
	}

	// Uncomment following line to enable logging
	// gocb.SetLogger(gocb.VerboseStdioLogger())

	// For a secure cluster connection, use `couchbases://<your-cluster-ip>` instead.
	connectionString := getEnvOrDefault("CB_CONNECTION_STRING", defaultConnectionString)
	username := getEnvOrDefault("CB_USERNAME", defaultUsername)
	password := getEnvOrDefault("CB_PASSWORD", defaultPassword)

	cluster, err := gocb.Connect("couchbase://"+connectionString, gocb.ClusterOptions{
		Authenticator: gocb.PasswordAuthenticator{
			Username: username,
			Password: password,
		},
	})
	if err != nil {
		panic(err)
	}
	defer cluster.Close(nil)

	bucket := cluster.Bucket(bucketName)

	err = bucket.WaitUntilReady(5*time.Second, nil)
	if err != nil {
		panic(err)
	}
	fmt.Println("Connected to bucket")

	col := bucket.Scope(scopeName).Collection(collectionName)
	fmt.Println("Got GoCB collection object")

	var totalDocs int
	for _, user := range users {
		var docCount int
		switch whatToDo {
		case belowRateLimit:
			docCount = PackageToLimit(user.Tier) / 2
		case atRateLimit:
			docCount = PackageToLimit(user.Tier)
		case aboveRateLimit:
			docCount = PackageToLimit(user.Tier) * 2
		default:
			panic("Unknown action")
		}

		totalDocs += docCount

		// Create and store a Document for each `user` in the `users` slice
		for range docCount {
			docID := uuid.New().String()
			_, err = col.Insert(docID,
				UserEventDocument{
					UserID:    user.UserID,
					RespondTo: "http://localhost:8080/result",
					Payload:   "{\"payload_key\": \"payload_value\"}",
					Header:    "{\"header_key\": \"header_value\"}",
				}, nil)
			if err != nil {
				panic(err)
			}
		}
		fmt.Printf("Inserted %d user event documents for user: %s with package %s\n", docCount, user.UserID, user.Tier)
	}
	fmt.Printf("Inserted a total of %d user event documents\n", totalDocs)
}

// readFromFile reads the data from the file in the path `filePath` and returns the data as a slice of `User` structs
func readFromFile(filePath string) ([]User, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}
	var users []User
	err = json.Unmarshal(data, &users)
	if err != nil {
		return nil, err
	}
	return users, nil
}
